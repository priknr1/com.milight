'use strict';

const Homey = require('homey');
const backoff = require('backoff');

/**
 * The {@link WifiDevice} class handles common functionalities for WiFi-devices in Homey. It exposes methods for handling
 * polling intervals and it features an initialization backoff strategy (which means; if enabled the device will try to init
 * and if it fails it will retry the onInit based on a fibonacci based interval).
 * @extends Homey.Device
 */
class WifiDevice extends Homey.Device {

	/**
	 * Method needs to be called manually from device.onInit(). It creates a initialization backoff strategy
	 * which will try to init a device over time if it failed.
	 * @param {Object} [options]
	 * @param {Object} [options.backOffStrategy] - Specification for initialization backoff strategy
	 * @param {number} [options.backOffStrategy.randomisationFactor=0] - Randomize the interval (0 - 1)
	 * @param {number} [options.backOffStrategy.initialDelay=10000] - After first failed init wait this long (ms)
	 * @param {number} [options.backOffStrategy.maxDelay=300000] - Max length of time between init retries (ms)
	 * @param {number} [options.backOffStrategy.maxTries=infinite] - Max number of initialization retries
	 */
	onInit(options = {}) {
		this.pollIntervals = {};

		// Create backoff strategy only at first init or after backOffStrategy has been reset
		if (options.hasOwnProperty('backOffStrategy') && !this.backOffStrategy) {

			// Wrap backoff methods
			this.resetBackOff = () => {
				if (!this.backOffStrategy) return new Error('no_active_backoff_strategy');
				this.log('onInit() -> reset backoff strategy');
				this.backOffStrategy.reset();
				this.backOffStrategy = null;
			};
			this.nextBackOff = () => {
				if (!this.backOffStrategy) return new Error('no_active_backoff_strategy');
				this.backOffStrategy.backoff();
			};

			// Create backoff strategy
			this.backOffStrategy = backoff.fibonacci({
				randomisationFactor: options.backOffStrategy.randomisationFactor || 0,
				initialDelay: options.backOffStrategy.initialDelay || 10000,
				maxDelay: options.backOffStrategy.maxDelay || 300000,
			});

			// If provided, set max number of tries
			if (typeof options.backOffStrategy.maxTries === 'number') {
				this.backOffStrategy.failAfter(options.backOffStrategy.maxTries);
			}

			// After back off has been executed, call onBackOffReady() (if provided) or onInit()
			this.backOffStrategy.on('ready', (number, delay) => {
				this.log(`onInit() -> retry init -> attempt ${number} -> delay ${delay}ms`);
				if (typeof options.backOffStrategy.onBackOffReady === 'function') {
					options.backOffStrategy.onBackOffReady.call(this);
				} else {
					this.onInit();
				}
			});

			// If custom onBackOffFailed() method is provided, bind it to the fail event
			if (options.backOffStrategy.onBackOffFailed) {
				this.backOffStrategy.on('fail', () => options.backOffStrategy.onBackOffFailed.call(this));
			} else {
				this.backOffStrategy.on('fail', () => this.error('onInit() -> backoff strategy failed'));
			}

			this.log('onInit() -> initialization backoff strategy initialized');
		}
	}

	/**
	 * Method that adds a poll interval to the list, and starts polling on the provided interval.
	 * @param {Object} options
	 * @param {string} options.id - Custom id of poll interval
	 * @param {function} options.fn - Method that will be called when polling
	 * @param {number} options.interval - Time in ms between polling intervals
	 */
	registerPollInterval(options = {}) {
		if (typeof this.pollIntervals === 'undefined') this.pollIntervals = {};
		if (this.pollIntervals.hasOwnProperty(options.id)) this.deregisterPollInterval(options.id);
		this.pollIntervals[options.id] = setInterval(options.fn, options.interval);
		this.log(`registered polling interval (id: ${options.id}, interval: ${options.interval}ms)`);
	}

	/**
	 * Method that clears the poll interval and removes the registered interval from the list.
	 * @param {string} id - poll interval identifier
	 */
	deregisterPollInterval(id) {
		clearInterval(this.pollIntervals[id]);
		delete this.pollIntervals[id];
		this.log(`de-registered polling interval (id: ${id})`);
	}

	/**
	 * This method will be called when the device has been deleted, it makes
	 * sure the client is properly destroyed and left over settings are removed.
	 */
	onDeleted() {
		// Deregister all poll intervals
		Object.keys(this.pollIntervals || {}).forEach(id => this.deregisterPollInterval(id));
	}
}

module.exports = WifiDevice;
