'use strict';

const Homey = require('homey');
const _ = require('underscore');
const OAuth2Util = require('./OAuth2Util');
const WifiDriver = require('./../WifiDriver');
const OAuth2Account = require('./OAuth2Account');
const OAuth2ClientManager = require('./OAuth2ClientManager');

/**
 * The {@link OAuth2Driver} class handles the OAuth2 pairing wizard if an oauth2ClientConfiguration is provided by
 * calling super.onInit(oauth2ClientConfiguration) or if Homey.app.oauth2ClientConfig is set to a valid
 * {@link OAuth2Client} configuration. It will make sure Homey.app.OAuth2ClientManager exists and exposes the
 * {@link OAuth2Client} associated with this driver via the oauth2Client property.
 * @extends WifiDriver
 * @example
 *
 * const OAuth2Driver = require('homey-wifidriver').OAuth2Driver;
 * const ExampleAPI = require('example-api');
 *
 * const oauth2ClientConfig = {
 *	url: `https://api.example.com/authorize?response_type=code&client_id=${Homey.env.API_CLIENT_ID}&redirect_uri=https://callback.athom.com/oauth2/callback/`,
 * 	tokenEndpoint: 'https://api.example.com/token',
 *	key: Homey.env.API_CLIENT_ID,
 * 	secret: Homey.env.API_CLIENT_SECRET,
 * 	allowMultipleAccounts: false,
 * };
 *
 * class myDriver extends OAuth2Driver { // Which extends WifiDriver
 *
 *	onInit(){
 *		// This will override onPair() to handle OAuth2 pairing
 *		super.onInit({oauth2ClientConfig});
 *	}
 *
 *	// This method will be called if a oauth2ClientConfig is provided onInit. The data object contains
 *	// an authenticated OAuth2Account instance which will be destroyed automatically after pairing
 *	// has ended.
 *	onPairOAuth2ListDevices(data) {
 *
 *		// Create temporary API client with temporary account
 *		const exampleApiClient = new ExampleAPI({
 *			oauth2Account: data.oauth2Account,
 *		});
 *
 *		// Return promise that fetches devices from account
 *		return exampleApiClient.fetchDevices()
 *			.then(devices => {
 *				exampleApiClient.destroy();
 *				return devices;
 *			})
 *		}
 *	}
 */
class OAuth2Driver extends WifiDriver {

	/**
	 * This method needs to be called from a driver.onInit(), it will create an {@link OAuth2Client}
	 * and override the default onPair() method to handle the OAuth2 Flow.
	 * @param {Object} options
	 * @param {Object} options.oauth2ClientConfig - {@link OAuth2Client} configuration object
	 * @param {string} options.oauth2ClientConfig.url - OAuth2 authorization url
	 * @param {string} options.oauth2ClientConfig.tokenEndpoint - OAuth2 token endpoint
	 * @param {string} options.oauth2ClientConfig.key - OAuth2 client key
	 * @param {string} options.oauth2ClientConfig.secret - OAuth2 client secret
	 * @param {string} options.oauth2ClientConfig.allowMultipleAccounts - Specifies whether multiple accounts per
	 * client are allowed
	 */
	onInit(options = {}) {

		// Check if OAuth2 client config is provided
		if (options.oauth2ClientConfig || Homey.app.oauth2ClientConfig) {

			this.oauth2ClientConfig = options.oauth2ClientConfig || Homey.app.oauth2ClientConfig;
			this.oauth2ClientConfig.log = this.log.bind(this);

			// If there is no client manager present create one
			if (!(Homey.app.OAuth2ClientManager instanceof OAuth2ClientManager)) {
				Homey.app.OAuth2ClientManager = new OAuth2ClientManager({ log: Homey.app.log.bind(Homey.app) });
			}

			// Create a new client or return existing one depending on configuration
			this.oauth2Client = Homey.app.OAuth2ClientManager.createClient(this.oauth2ClientConfig);

			this.log('onInit() -> initialized OAuth2 client');

			// Override the onPair method
			this.onPair = this.customOAuth2OnPair.bind(this);

			this.log('onInit() -> redirect onPair() to OAuth2 pairing flow');
		}
	}

	/**
	 * This method will be called when the user starts pairing a new device,
	 * it executes a OAuth2 flow to retrieve devices linked to the users account.
	 * @param socket
	 */
	customOAuth2OnPair(socket) {

		// If only one account allowed and it is already present
		let oauth2Account;
		if (!this.oauth2ClientConfig.allowMultipleAccounts && this.oauth2Client.registeredAccounts().length === 1) {
			oauth2Account = this.oauth2Client.getAccount();
		} else {
			oauth2Account = new OAuth2Account({ oauth2Client: this.oauth2Client });

			// Destroy oauth2Account when pairing is finished, device.onInit() will create permanent account
			socket.on('disconnect', () => oauth2Account.destroy());
		}

		// Determine if new OAuth2 pair flow is necessary
		if (this.oauth2Client.registeredAccounts().length === 0 ||
			(this.oauth2Client.registeredAccounts().length === 1 &&
			typeof this.oauth2Client.getAccount().accessToken === 'undefined') ||
			this.oauth2ClientConfig.allowMultipleAccounts) {

			OAuth2Util.generateOAuth2Callback(oauth2Account, socket);
		} else {
			// Already one account registered which is the maximum according to config
			socket.emit('authorized');
		}

		// Listen for list_devices request
		socket.on('list_devices', (data = {}, callback) => {

			// Put OAuth2 account in data object
			data.oauth2Account = oauth2Account;

			this.log('customOAuth2OnPair() -> fetch list devices');

			// Call driver's OAuth2 list devices method to ask for devices list
			this.onPairOAuth2ListDevices(data)
				.then((devices = []) => {

					// Add OAuth2Account to store so that device can retrieve it onInit
					devices.forEach(device => {
						if (!device.hasOwnProperty('store')) device.store = {};

						// Only override tempOAuth2Account if not yet provided
						if (!device.store.hasOwnProperty('tempOAuth2Account')) {

							// Store only these three properties of account
							device.store.tempOAuth2Account = _.pick(oauth2Account, 'accessToken', 'refreshToken', 'oauth2Client');

							// If device data contains oauth2 account id store it as well
							if (device.data.hasOwnProperty('oauth2AccountId')) {
								device.store.tempOAuth2Account.id = device.data.oauth2AccountId;
							}
						}
					});

					return callback(null, devices);
				})
				.catch(err => {
					this.error(err.stack);
					return callback(err);
				});
		});
	}
}

module.exports = OAuth2Driver;
