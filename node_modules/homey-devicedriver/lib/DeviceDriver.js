'use strict';

const _ = require('underscore');

const events = require('events');

const Device = require('./Device');

const SAVED_STATE_TIMEOUT = 30 * 60 * 1000; // 30 min. Duration window within stored capability values are considered valid

class DeviceDriver extends events.EventEmitter {

	/**
	 * DeviceDriver constructor, takes a driverId
	 * and options object. Creates get and set functions
	 * for all capabilities the driver supports.
	 * @param driverId
	 * @param options
	 */
	constructor(driverId, options) {
		super();

		this.devices = [];
		this.uninitializedDevices = [];
		this.capabilities = {};
		this.driverId = driverId;
		this.driver = _.findWhere(Homey.manifest.drivers, { id: driverId });

		// Override default options with provided options object
		this.options = Object.assign({
			debug: false,
			capabilities: {},
			initDevice: (device, callback) => callback(null, device),
		}, options);

		this.init = this.init.bind(this);
		this.added = this.added.bind(this);
		this.deleted = this.deleted.bind(this);
		this.settings = this.settings.bind(this);

		// Register unload callback
		if (Homey && Homey.on) {
			Homey.on('unload', this._onUnload.bind(this));
		}

		// Expose pair object on root scope
		if (typeof this.options.pair === 'function') this.pair = this.options.pair;

		// Loop over all capabilities specified in app.json
		this.driver.capabilities.forEach(capabilityId => {
			if (typeof this.options.capabilities[capabilityId] === 'undefined') {
				throw new Error(`missing_options_capability: ${capabilityId}`);
			}

			// Create capability object
			this.capabilities[capabilityId] = {};

			// Define get function for capability
			this.capabilities[capabilityId].get = (deviceData, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);

				if (typeof this.options.capabilities[capabilityId].get === 'function') {
					this.options.capabilities[capabilityId].get(device, (err, result) => {
						this._log(`get ${capabilityId} -> ${err || result}`);
						return callback(err, result);
					});
				} else {
					this._log(`get ${capabilityId} -> ${device.capabilities[capabilityId].get()}`);
					return callback(null, device.capabilities[capabilityId].get());
				}
			};

			// Define set function for capability
			this.capabilities[capabilityId].set = (deviceData, value, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);
				this.options.capabilities[capabilityId].set(device, value, (err, result) => {
					if (err) return callback(err);
					this._log('set', capabilityId, result);
					device.capabilities[capabilityId].set(result);
					return callback(err, result);
				});
			};
		});
	}

	/**
	 * Method that will be called on driver
	 * initialisation.
	 * @param devicesData
	 * @param callback
	 * @returns {*}
	 */
	init(devicesData, callback) {
		if (devicesData.length < 1) return callback(null, true);
		this._log(`init() -> initialize ${devicesData.length} devices`);
		const initializationPromises = [];

		// Loop over all installed devices and start device initialization
		devicesData.forEach((deviceData) => initializationPromises.push(this.initDevice(deviceData)));

		// Wait for all devices to have been initialized
		Promise.all(initializationPromises)
			.then(() => {
				this._log(`init() -> all ${initializationPromises.length} devices are initialized`);
				return callback(null, true);
			})
			.catch(err => {
				this._error(`init() -> one or more devices failed to initialize`, err);
				return callback(err);
			});
	}

	/**
	 * Method that will be called when a user
	 * adds a device.
	 * @param deviceData
	 * @param callback
	 * @returns {*}
	 */
	added(deviceData, callback) {
		this.initDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Method that will be called when a user
	 * deletes a device.
	 * @param deviceData
	 * @param callback
	 */
	deleted(deviceData, callback) {
		this.deleteDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Initializes a device.
	 * @param deviceData
	 * @param retry - true if retrying to prevent state change
	 */
	initDevice(deviceData, retry) {
		if (!deviceData) return Promise.reject(new Error('invalid_device_data'));
		this._log('initDevice() -> start device initialization');
		if (!retry) this.setUnavailable(deviceData, __('initializing'));
		return new Promise(resolve => {
			let device = (!retry) ? new Device(deviceData, {
					capabilities: this.driver.capabilities || [],
					settings: this.driver.settings || []
				}) : this.getDevice(deviceData, this.uninitializedDevices);

			// Bind unavailable event
			device.on('unavailable', () => {
				this._log('deviceWentOffline() -> mark as offline and start search');
				this.initDevice(device.data);
			});

			// Bind capability changed events to emit realtime
			this.driver.capabilities.forEach(capability => {
				device.on(`${capability}_changed`, value => {
					this._log(`${capability}_changed -> ${value}`);
					this.realtime(device.data, capability, value)
				});
			});

			this.options.initDevice(device, (err, initializedDevice) => {
				if (err) {
					this._error('initDevice() -> failed to initialize device');
					if (!retry) this.setUnavailable(deviceData, __('not_found'));
					setTimeout(() => {
						this._log(`initDevice() -> retry device initialization (tries: ${device.initializationRetryCount}`);
						this.initDevice(deviceData, true);
					}, device.getInitializationRetryInterval());
					device.initializationRetryCount++;
					this.uninitializedDevices.push(device);
					return resolve();
				}

				this.getSettings(deviceData, (err, settings) => {
					if (err) return this._error('getSettings() -> error', err);
					for (let key in settings) {
						initializedDevice.settings[key] = settings[key];
					}
				});

				if (this.options.capabilities) {
					for (let x in this.options.capabilities) {
						if (this.options.capabilities[x]) {

							// Set capability pollers
							if (typeof this.options.capabilities[x].pollInterval === 'number') {
								initializedDevice.pollingIntervals[x] = setInterval(() => {
									this.capabilities[x].get(deviceData, (err) => {
										if (err) this._error(`polling() -> ${x} -> failed`, err);
									});
								}, this.options.capabilities[x].pollInterval);
							}

							// Persist values over reboot
							if (this.options.capabilities[x].persistOverReboot) {
								const data = Homey.manager('settings').get(`devicedriver_${this.driverId}_${JSON.stringify(deviceData)}_state_${x}`);
								if (data) {
									const when = new Date(data.when);
									if (((new Date) - when) < SAVED_STATE_TIMEOUT) {
										initializedDevice.capabilities[x].set(data.state);
										this._log(`initDevice() -> restored saved state ${x}`, data.state);
									}
									Homey.manager('settings').unset(`devicedriver_${this.driverId}_${JSON.stringify(deviceData)}_state_${x}`);
								}
							}
						}
					}
				}
				if (retry) this.uninitializedDevices = _.without(this.uninitializedDevices, this.getDevice(deviceData, this.uninitializedDevices));
				this.devices.push(initializedDevice);
				this.setAvailable(deviceData);
				return resolve(initializedDevice);
			});
		});
	}

	/**
	 * Method called when a user
	 * deletes a device from Homey.
	 * @param deviceData
	 */
	deleteDevice(deviceData) {
		if (!deviceData) {
			this._error('deleteDevice() -> called without deviceData parameter');
			return Promise.reject(new Error('invalid_device_data'));
		}

		const device = this.getDevice(deviceData);
		if (device instanceof Error) {
			this._error('deleteDevice() -> called with invalid deviceData parameter');
			return Promise.reject(new Error('invalid_device'));
		}

		return new Promise(resolve => {
			const prevLength = this.devices.length;
			if (device) device.destroy();
			this.devices = _.without(this.devices, this.getDevice(deviceData));
			this._log(`deleteDevice() -> device destroyed and removed from list, prev size ${prevLength}, current size ${this.devices.length}`);
			return resolve(device);
		});
	}

	/**
	 * Returns device from internal devices list.
	 * @param deviceData
	 * @param list
	 * @returns {*}
	 */
	getDevice(deviceData, list) {
		if (!deviceData) {
			this._error('getDevice() -> called without deviceData parameter');
			return new Error('invalid_device_data');
		}
		return _.find(list || this.devices, device => _.isEqual(device.data, deviceData)) || new Error('invalid_device');
	}

	settings(deviceData, newSettingsObj, oldSettingsObj, changedKeysArr, callback) {
		// run when the user has changed the device's settings in Homey.
		// changedKeysArr contains an array of keys that have been changed, for your convenience :)

		// always fire the callback, or the settings won't change!
		// if the settings must not be saved for whatever reason:
		// callback( "Your error message", null );
		// else
		console.log(newSettingsObj);
		const device = this.getDevice(deviceData);

		for (let setting in newSettingsObj) {
			device.settings[setting] = newSettingsObj[setting];
		}
		// device.settings.newS
		return callback(null, true);

	}


	/**
	 * Fired when the app unloads
	 * to save all battery data
	 * @private
	 */
	_onUnload() {
		this.devices.forEach(device => {
			for (let x in device.capabilities) {
				if (this.options.capabilities[x].persistOverReboot && typeof device.capabilities[x].state !== 'undefined') {
					this._log(`_onUnload -> store devicedriver_${this.driverId}_${JSON.stringify(device.data)}_state_${x} -> ${device.capabilities[x].state}`);
					Homey.manager('settings').set(`devicedriver_${this.driverId}_${JSON.stringify(device.data)}_state_${x}`, {
						state: device.capabilities[x].get(),
						when: new Date()
					});
				}
			}
		});
	}

	/**
	 * Log method, log level info.
	 */
	_log() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[info]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level warn.
	 */
	_warn() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[warn]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level error.
	 */
	_error() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[error]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.error.apply(null, args);
	}
}

/**
 * Create current timestamp,
 * HH:MM:SS:sss
 * @returns {string}
 */
function timestamp() {
	const d = new Date();
	return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}:${pad(d.getMilliseconds())}`;
}

/**
 * Pad a value with zero if necessary.
 * @param value
 * @returns {string}
 */
function pad(value) {
	return (value < 10) ? `0${value}` : value;
}

module.exports = DeviceDriver;
