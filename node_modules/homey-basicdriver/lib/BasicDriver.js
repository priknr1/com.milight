'use strict';

// TODO Lifx like debouncer
/*
 when capability option debouncer is set, call the set after timeout debounce with aditional paramter
 which holds all the updated values, you could also expose another function (if debouncer option is string)
 then call that function so that multiple capabilities can be set via one function call
 */

const _ = require('underscore');

const events = require('events');

const Device = require('./Device');

const SAVED_STATE_TIMEOUT = 30 * 60 * 1000; // 30 min. Duration window within stored capability values are considered valid

class BasicDriver extends events.EventEmitter {

	/**
	 * BasicDriver constructor, takes a driverId
	 * and options object. Creates get and set functions
	 * for all capabilities the driver supports.
	 * @param driverId
	 * @param options
	 */
	constructor(driverId, options) {
		super();

		this.devices = [];
		this.uninitializedDevices = [];
		this.capabilities = {};
		this.driverId = driverId;
		this.driver = _.findWhere(Homey.manifest.drivers, { id: driverId });

		// Override default options with provided options object
		this.options = Object.assign({
			debug: false,
			capabilities: {},
			initDevice: (device, callback) => callback(null, device),
		}, options);

		this.init = this.init.bind(this);
		this.added = this.added.bind(this);
		this.deleted = this.deleted.bind(this);
		this.settings = this.settings.bind(this);

		// Register unload callback
		if (Homey && Homey.on) {
			Homey.on('unload', this._onUnload.bind(this));
		}

		// Expose pair object on root scope
		if (typeof this.options.pair === 'function') this.pair = this.options.pair;

		// Loop over all capabilities specified in app.json
		this.driver.capabilities.forEach(capabilityId => {
			if (typeof this.options.capabilities[capabilityId] === 'undefined') {
				throw new Error(`missing_options_capability: ${capabilityId}`);
			}

			// Create capability object
			this.capabilities[capabilityId] = {};

			// Define get function for capability
			this.capabilities[capabilityId].get = (deviceData, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);

				if (typeof this.options.capabilities[capabilityId].get === 'function') {
					this.options.capabilities[capabilityId].get(device, (err, result) => {
						this._log(`get ${capabilityId} -> ${err || result}`);
						return callback(err, result);
					});
				} else {
					this._log(`get ${capabilityId} -> ${device.capabilities[capabilityId].get()}`);
					return callback(null, device.capabilities[capabilityId].get());
				}
			};

			// Define set function for capability
			this.capabilities[capabilityId].set = (deviceData, value, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);
				this.options.capabilities[capabilityId].set(device, value, (err, result) => {
					if (err) return callback(err);
					this._log('set', capabilityId, result);
					device.capabilities[capabilityId].set(result);
					return callback(err, result);
				});
			};
		});
	}

	/**
	 * Method that will be called on driver
	 * initialisation.
	 * @param devicesData
	 * @param callback
	 * @returns {*}
	 */
	init(devicesData, callback) {
		if (devicesData.length < 1) return callback(null, true);
		this._log(`init() -> initialize ${devicesData.length} devices`);
		const initializationPromises = [];

		// Loop over all installed devices and start device initialization
		devicesData.forEach((deviceData) => initializationPromises.push(this.initDevice(deviceData)));

		// Wait for all devices to have been initialized
		Promise.all(initializationPromises)
			.then(() => {
				this._log(`init() -> all ${initializationPromises.length} devices are initialized`);
				return callback(null, true);
			})
			.catch(err => {
				this._error(`init() -> one or more devices failed to initialize`, err);
				return callback(err);
			});
	}

	/**
	 * Method that will be called when a user
	 * adds a device.
	 * @param deviceData
	 * @param callback
	 * @returns {*}
	 */
	added(deviceData, callback) {
		this.initDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Method that will be called when a user
	 * deletes a device.
	 * @param deviceData
	 * @param callback
	 */
	deleted(deviceData, callback) {
		this.deleteDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Initializes a device.
	 * @param deviceData
	 * @param retry - true if retrying to prevent state change
	 */
	initDevice(deviceData, retry) {
		if (!deviceData) return Promise.reject(new Error('invalid_device_data'));
		this._log('initDevice() -> start device initialization');
		if (!retry) this.setUnavailable(deviceData, __('initializing'));
		return new Promise(resolve => {
			let device = (!retry) ? new Device(deviceData, {
					capabilities: this.driver.capabilities || [],
					settings: this.driver.settings || []
				}) : this.getDevice(deviceData, this.uninitializedDevices);

			// Bind unavailable event
			device.on('unavailable', () => {
				this._log('deviceWentOffline() -> mark as offline and start search');
				this.initDevice(device.data);
			});

			// Bind unavailable event
			device.on('reinit', () => {
				this._log('initDevice() -> reinit device');
				this.initDevice(device.data);
			});

			// Bind capability changed events to emit realtime
			this.driver.capabilities.forEach(capability => {
				device.on(`${capability}_changed`, value => {
					this._log(`${capability}_changed -> ${value}`);
					this.realtime(device.data, capability, value)
				});
			});

			this.options.initDevice(device, (err, initializedDevice) => {
				if (err) {
					this._error('initDevice() -> failed to initialize device');
					if (!retry) this.setUnavailable(deviceData, __('not_found'));
					setTimeout(() => {
						this._log(`initDevice() -> retry device initialization (tries: ${device.initializationRetryCount}`);
						this.initDevice(deviceData, true);
					}, device.getInitializationRetryInterval());
					device.initializationRetryCount++;
					this.uninitializedDevices.push(device);
					return resolve();
				}

				this.getSettings(deviceData, (err, settings) => {
					if (err) return this._error('getSettings() -> error', err);
					for (let key in settings) {
						initializedDevice.settings[key].set(settings[key]);
					}
				});

				if (this.options.capabilities) {
					for (let x in this.options.capabilities) {
						if (this.options.capabilities[x]) {

							// Set capability pollers
							if (typeof this.options.capabilities[x].pollInterval === 'number') {
								initializedDevice.pollingIntervals[x] = setInterval(() => {
									this.capabilities[x].get(deviceData, (err) => {
										if (err) this._error(`polling() -> ${x} -> failed`, err);
									});
								}, this.options.capabilities[x].pollInterval);
							}

							// Persist values over reboot
							if (this.options.capabilities[x].persistOverReboot) {
								const data = Homey.manager('settings').get(`basicdriver_${this.driverId}_${JSON.stringify(deviceData)}_state_${x}`);
								if (data) {
									const when = new Date(data.when);
									if (((new Date) - when) < SAVED_STATE_TIMEOUT) {
										initializedDevice.capabilities[x].set(data.state);
										this._log(`initDevice() -> restored saved state ${x}`, data.state);
									}
									Homey.manager('settings').unset(`basicdriver_${this.driverId}_${JSON.stringify(deviceData)}_state_${x}`);
								}
							}
						}
					}
				}
				if (retry) this.uninitializedDevices = _.without(this.uninitializedDevices, this.getDevice(deviceData, this.uninitializedDevices));

				// If duplicate of device was initialized due to initDevice retries, overwrite its properties
				if (this.getDevice(initializedDevice.data) instanceof Device){
					Object.assign(this.getDevice(initializedDevice.data), initializedDevice);
					this.setAvailable(deviceData);
					return resolve(this.getDevice(initializedDevice.data));
				}
				this.devices.push(initializedDevice);
				this.setAvailable(deviceData);
				return resolve(initializedDevice);
			});
		});
	}

	/**
	 * Method called when a user
	 * deletes a device from Homey.
	 * @param deviceData
	 */
	deleteDevice(deviceData) {
		if (!deviceData) {
			this._error('deleteDevice() -> called without deviceData parameter');
			return Promise.reject(new Error('invalid_device_data'));
		}

		const device = this.getDevice(deviceData);
		if (device instanceof Error) {
			this._error('deleteDevice() -> called with invalid deviceData parameter');
			return Promise.reject(new Error('invalid_device'));
		}

		return new Promise(resolve => {
			const prevLength = this.devices.length;
			if (device) device.destroy();
			this.devices = _.without(this.devices, this.getDevice(deviceData));
			this._log(`deleteDevice() -> device destroyed and removed from list, prev size ${prevLength}, current size ${this.devices.length}`);
			return resolve(device);
		});
	}

	/**
	 * Returns device from internal devices list.
	 * @param deviceData
	 * @param list
	 * @returns {*}
	 */
	getDevice(deviceData, list) {
		if (!deviceData) {
			this._error('getDevice() -> called without deviceData parameter');
			return new Error('invalid_device_data');
		}
		return _.find(list || this.devices, device => _.isEqual(device.data, deviceData)) || new Error('invalid_device');
	}

	settings(deviceData, newSettingsObj, oldSettingsObj, changedKeysArr, callback) {
		const device = this.getDevice(deviceData);
		for (let setting in newSettingsObj) {
			device.settings[setting].set(newSettingsObj[setting]);
		}
		return callback(null, true);
	}


	/**
	 * Fired when the app unloads
	 * to save all battery data
	 * @private
	 */
	_onUnload() {
		this.devices.forEach(device => {
			for (let x in device.capabilities) {
				if (this.options.capabilities[x].persistOverReboot && typeof device.capabilities[x].state !== 'undefined') {
					this._log(`_onUnload -> store basicdriver_${this.driverId}_${JSON.stringify(device.data)}_state_${x} -> ${device.capabilities[x].state}`);
					Homey.manager('settings').set(`basicdriver_${this.driverId}_${JSON.stringify(device.data)}_state_${x}`, {
						state: device.capabilities[x].get(),
						when: new Date()
					});
				}
			}
		});
	}

	/**
	 * Log method, log level info.
	 */
	_log() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[info]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level warn.
	 */
	_warn() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[warn]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level error.
	 */
	_error() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[error]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.error.apply(null, args);
	}
}

/**
 * Create current timestamp,
 * HH:MM:SS:sss
 * @returns {string}
 */
function timestamp() {
	const d = new Date();
	return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}:${pad(d.getMilliseconds())}`;
}

/**
 * Pad a value with zero if necessary.
 * @param value
 * @returns {string}
 */
function pad(value) {
	return (value < 10) ? `0${value}` : value;
}

module.exports = BasicDriver;
