'use strict';

const chai = require('chai');
const Device = require('./../lib/Device');

const assert = chai.assert;
const should = chai.should;

const deviceDataMock = { id: 'a23sd4f5g67h8j9k' };
const optionsMock = {
	capabilities: ['onoff', 'target_temperature', 'thermostat_mode'],
};

describe('Device', () => {
	it('should fail to initialize without deviceData', () => {
		const device = new Device();
		assert.typeOf(device, 'Error');
	});
	it('should initialize with deviceData', () => {
		const device = new Device(deviceDataMock);
		assert.instanceOf(device, Device);
		assert.isObject(device.data);
		assert.deepEqual(device.data, deviceDataMock);
	});
	it('should initialize without options', () => {
		const device = new Device(deviceDataMock);
		assert.instanceOf(device, Device);
		assert.isObject(device.options);
		assert.property(device.options, 'capabilities');
		assert.isArray(device.options.capabilities);
		assert.lengthOf(device.options.capabilities, 0);
	});
	it('should initialize with options', () => {
		const device = new Device(deviceDataMock, optionsMock);
		assert.instanceOf(device, Device);
		assert.isObject(device.options);
		assert.property(device.options, 'capabilities');
		assert.isArray(device.options.capabilities);
		assert.equal(device.options.capabilities, optionsMock.capabilities);
		assert.lengthOf(device.options.capabilities, 3);
	});
	it('should create get functions for all capabilities in options', () => {
		const device = new Device(deviceDataMock, optionsMock);
		optionsMock.capabilities.forEach(capability => {
			assert.property(device.capabilities, capability);
			assert.isObject(device.capabilities[capability]);
			assert.property(device.capabilities[capability], 'get');
			assert.typeOf(device.capabilities[capability].get, 'function');
		});
	});
	it('should create set functions for all capabilities in options', () => {
		const device = new Device(deviceDataMock, optionsMock);
		optionsMock.capabilities.forEach(capability => {
			assert.property(device.capabilities, capability);
			assert.isObject(device.capabilities[capability]);
			assert.property(device.capabilities[capability], 'set');
			assert.typeOf(device.capabilities[capability].set, 'function');
		});
	});
	it('should initialize all capabilities with undefined state', () => {
		const device = new Device(deviceDataMock, optionsMock);
		optionsMock.capabilities.forEach(capability => {
			assert.property(device.capabilities, capability);
			assert.isObject(device.capabilities[capability]);
			assert.property(device.capabilities[capability], 'state');
			assert.equal(device.capabilities[capability].state, undefined);
		});
	});
	it('should set a capabilities value', () => {
		const value = 'testValue';
		const device = new Device(deviceDataMock, optionsMock);
		optionsMock.capabilities.forEach(capability => {
			device.capabilities[capability].set(value);
			assert.equal(device.capabilities[capability].state, value);
		});
	});
	it('should get a capabilities value', () => {
		const value = 'testValue';
		const device = new Device(deviceDataMock, optionsMock);
		optionsMock.capabilities.forEach(capability => {
			device.capabilities[capability].set(value);
			assert.equal(device.capabilities[capability].get(), value);
		});
	});
	it('should not emit events when capability value changed from undefined', () => {
		const value = 'testValue';
		const device = new Device(deviceDataMock, optionsMock);
		device.on(`${optionsMock.capabilities[0]}_changed`, updatedValue => {
			throw Error(`${optionsMock.capabilities[0]}_changed event emitted with value ${updatedValue}`);
		});
		device.capabilities[optionsMock.capabilities[0]].set(value);
	});
	it('should not emit events when capability values updates but does not change', () => {
		const value = 'testValue';
		const device = new Device(deviceDataMock, optionsMock);
		device.on(`${optionsMock.capabilities[0]}_changed`, updatedValue => {
			throw Error(`${optionsMock.capabilities[0]}_changed event emitted with value ${updatedValue}`);
		});
		device.capabilities[optionsMock.capabilities[0]].set(value);
		device.capabilities[optionsMock.capabilities[0]].set(value);
	});
	it('should emit events when capability values change', (done) => {
		const value = 'testValue';
		const device = new Device(deviceDataMock, optionsMock);
		device.on(`${optionsMock.capabilities[0]}_changed`, updatedValue => {
			assert.equal(value, updatedValue);
			done();
		});
		device.capabilities[optionsMock.capabilities[0]].set('not_undefined_value');
		device.capabilities[optionsMock.capabilities[0]].set(value);
	});
	it('should return current initialization retry interval values', () => {
		const device = new Device(deviceDataMock, optionsMock);
		assert.equal(device.initializationRetryCount, 0);

		assert.equal(device.getInitializationRetryInterval(), 15000);
		assert.equal(device.initializationRetryCount, 1);

		assert.equal(device.getInitializationRetryInterval(), 15000);
		assert.equal(device.initializationRetryCount, 2);

		assert.equal(device.getInitializationRetryInterval(), 15000);
		assert.equal(device.initializationRetryCount, 3);

		assert.equal(device.getInitializationRetryInterval(), 60000);
		assert.equal(device.initializationRetryCount, 4);

		assert.equal(device.getInitializationRetryInterval(), 60000);
		assert.equal(device.initializationRetryCount, 5);

		assert.equal(device.getInitializationRetryInterval(), 60000);
		assert.equal(device.initializationRetryCount, 6);

		assert.equal(device.getInitializationRetryInterval(), 60000);
		assert.equal(device.initializationRetryCount, 7);

		assert.equal(device.getInitializationRetryInterval(), 900000);
		assert.equal(device.initializationRetryCount, 8);

		assert.equal(device.getInitializationRetryInterval(), 900000);
		assert.equal(device.initializationRetryCount, 9);

		assert.equal(device.getInitializationRetryInterval(), 900000);
		assert.equal(device.initializationRetryCount, 10);
	});
	it('should be destroyed', () => {
		const device = new Device(deviceDataMock, optionsMock);
		device.destroy();
		assert.deepEqual(device.pollingIntervals, {});
	});
});